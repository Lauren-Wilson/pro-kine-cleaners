from __future__ import annotations
import duckdb
from pathlib import Path
DB_PATH=Path('data/cleaners.duckdb')
SCHEMA_SQL='''\
CREATE TABLE IF NOT EXISTS candidates (
  candidate_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  full_name_or_handle TEXT,
  platform TEXT,
  post_title_or_snippet TEXT,
  post_url TEXT UNIQUE,
  posted_at TIMESTAMP,
  location_text TEXT,
  service_types TEXT,
  availability TEXT,
  rate_info TEXT,
  contact_method TEXT,
  intent_signal TEXT,
  quality_notes TEXT,
  source_screenshot_path TEXT,
  match_score INTEGER,
  first_seen_at TIMESTAMP,
  last_seen_at TIMESTAMP,
  is_archived BOOLEAN DEFAULT FALSE,
  archived_at TIMESTAMP,
  status TEXT DEFAULT 'not_started',
  outreach_channel TEXT,
  outreach_last_sent_at TIMESTAMP,
  hired BOOLEAN DEFAULT FALSE,
  hired_from_source TEXT
);
CREATE TABLE IF NOT EXISTS runs (
  run_id TEXT PRIMARY KEY,
  run_ts TIMESTAMP,
  items_found INTEGER,
  items_kept INTEGER,
  duplicates_dropped INTEGER
);
CREATE TABLE IF NOT EXISTS run_items (
  run_id TEXT,
  candidate_id BIGINT,
  PRIMARY KEY (run_id, candidate_id)
);
CREATE TABLE IF NOT EXISTS outreach_log (
  outreach_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  candidate_id BIGINT,
  channel TEXT,
  variant TEXT,
  sent_at TIMESTAMP,
  notes TEXT
);
'''

def get_conn():
  DB_PATH.parent.mkdir(parents=True, exist_ok=True)
  con=duckdb.connect(DB_PATH.as_posix()); con.execute(SCHEMA_SQL); return con

def upsert_candidates(con, df, run_id, run_ts):
  con.register('new_candidates_view', df)
  con.execute("""
    CREATE TEMP TABLE tmp_candidates AS
    SELECT
      full_name_or_handle, platform, post_title_or_snippet, post_url,
      CASE WHEN posted_at IS NULL OR posted_at = '' THEN NULL ELSE CAST(posted_at AS TIMESTAMP) END AS posted_at,
      location_text, service_types, availability, rate_info, contact_method,
      intent_signal, quality_notes, source_screenshot_path, match_score
    FROM new_candidates_view
  """)
  con.execute(f"""
    MERGE INTO candidates t
    USING tmp_candidates s
    ON t.post_url = s.post_url
    WHEN MATCHED THEN UPDATE SET
      full_name_or_handle = COALESCE(NULLIF(s.full_name_or_handle, ''), t.full_name_or_handle),
      platform = COALESCE(NULLIF(s.platform, ''), t.platform),
      post_title_or_snippet = COALESCE(NULLIF(s.post_title_or_snippet, ''), t.post_title_or_snippet),
      posted_at = COALESCE(s.posted_at, t.posted_at),
      location_text = COALESCE(NULLIF(s.location_text, ''), t.location_text),
      service_types = COALESCE(NULLIF(s.service_types, ''), t.service_types),
      availability = COALESCE(NULLIF(s.availability, ''), t.availability),
      rate_info = COALESCE(NULLIF(s.rate_info, ''), t.rate_info),
      contact_method = COALESCE(NULLIF(s.contact_method, ''), t.contact_method),
      intent_signal = COALESCE(NULLIF(s.intent_signal, ''), t.intent_signal),
      quality_notes = COALESCE(NULLIF(s.quality_notes, ''), t.quality_notes),
      source_screenshot_path = COALESCE(NULLIF(s.source_screenshot_path, ''), t.source_screenshot_path),
      match_score = COALESCE(s.match_score, t.match_score),
      last_seen_at = '{'"+"'}'
    WHEN NOT MATCHED THEN INSERT (
      full_name_or_handle, platform, post_title_or_snippet, post_url, posted_at, location_text,
      service_types, availability, rate_info, contact_method, intent_signal, quality_notes,
      source_screenshot_path, match_score, first_seen_at, last_seen_at
    ) VALUES (
      s.full_name_or_handle, s.platform, s.post_title_or_snippet, s.post_url, s.posted_at, s.location_text,
      s.service_types, s.availability, s.rate_info, s.contact_method, s.intent_signal, s.quality_notes,
      s.source_screenshot_path, s.match_score, '{'"+"'}', '{'"+"'}'
    );
  """)
  con.execute("INSERT OR IGNORE INTO run_items (run_id, candidate_id) SELECT ?, candidate_id FROM candidates WHERE post_url IN (SELECT post_url FROM tmp_candidates)", [run_id])

def archive_stale_candidates(con, cutoff_days:int, as_of_ts:str):
  con.execute(f"UPDATE candidates SET is_archived=TRUE, archived_at='{as_of_ts}' WHERE is_archived=FALSE AND last_seen_at < (CAST('{as_of_ts}' AS TIMESTAMP) - INTERVAL '{cutoff_days} days')")

def insert_run(con, run_id, run_ts, stats):
  con.execute("INSERT INTO runs (run_id, run_ts, items_found, items_kept, duplicates_dropped) VALUES (?, ?, ?, ?, ?)", [run_id, run_ts, int(stats.get('items_found',0)), int(stats.get('items_kept',0)), int(stats.get('duplicates_dropped',0))])

def update_status(con, candidate_ids, status:str):
  if not candidate_ids: return
  qmarks=",".join(["?"]*len(candidate_ids))
  con.execute(f"UPDATE candidates SET status=? WHERE candidate_id IN ({qmarks})", [status, *candidate_ids])

def log_outreach(con, candidate_id:int, channel:str, variant:str, sent_at:str, notes:str=''):
  con.execute("INSERT INTO outreach_log (candidate_id, channel, variant, sent_at, notes) VALUES (?, ?, ?, ?, ?)", [candidate_id, channel, variant, sent_at, notes])
  con.execute("UPDATE candidates SET outreach_channel=?, outreach_last_sent_at=? WHERE candidate_id=?", [channel, sent_at, candidate_id])
